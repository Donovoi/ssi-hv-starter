# M2: RDMA Transport Implementation Plan

## Overview

Implement real RDMA operations using InfiniBand Verbs API to achieve **<100µs median latency** and **<500µs p99 latency** for remote page fault resolution.

**Target**: Replace current TCP fallback with production RDMA using `rdma-core` library (C bindings).

## Phase 1: Research & Setup (Days 1-2)

### 1.1 RDMA Binding Options

**Option A: rdma-core-sys** ✅ RECOMMENDED
- Direct FFI bindings to `libibverbs` from rdma-core
- Low-level, zero-cost abstraction
- Full control over RDMA operations
- Crate: Not on crates.io yet, will need custom bindings

**Option B: ibverbs** (Archived)
- Older Rust wrapper around libibverbs
- Last updated 2018, may be outdated
- Not actively maintained

**Option C: Custom FFI Bindings** ✅ PRAGMATIC CHOICE
- Use `bindgen` to generate Rust bindings from `infiniband/verbs.h`
- Full control and up-to-date with latest rdma-core
- Minimal dependencies

**Decision**: Start with **custom bindgen approach** for maximum control and latest API support.

### 1.2 System Requirements

**Host Setup:**
```bash
# Install RDMA libraries and tools
sudo apt-get install -y \
    rdma-core \
    libibverbs-dev \
    librdmacm-dev \
    ibverbs-utils \
    perftest

# Verify RDMA devices
ibv_devices
ibv_devinfo

# Check RDMA modules
lsmod | grep rdma
```

**Development Alternatives:**
1. **SoftRoCE** (Software RDMA over Ethernet) - For development without hardware
   ```bash
   sudo modprobe rdma_rxe
   sudo rdma link add rxe0 type rxe netdev eth0
   ```

2. **Real Hardware** - InfiniBand or RoCEv2 NICs (production)

### 1.3 Dependencies to Add

```toml
# rdma-transport/Cargo.toml
[build-dependencies]
bindgen = "0.70"

[dependencies]
libc = "0.2"
nix = { version = "0.29", features = ["socket", "poll"] }
```

## Phase 2: Bindgen Setup (Day 2)

### 2.1 Create Build Script

Create `rdma-transport/build.rs`:
- Generate bindings from `/usr/include/infiniband/verbs.h`
- Include essential RDMA structs and functions
- Handle platform-specific types

### 2.2 Key RDMA Structures

```rust
// Auto-generated by bindgen, wrapped for safety:

pub struct RdmaDevice {
    context: *mut ibv_context,
    pd: *mut ibv_pd,
}

pub struct RdmaQueuePair {
    qp: *mut ibv_qp,
    cq_send: *mut ibv_cq,
    cq_recv: *mut ibv_cq,
}

pub struct RdmaMemoryRegion {
    mr: *mut ibv_mr,
    addr: *mut u8,
    length: usize,
}
```

## Phase 3: Core RDMA Implementation (Days 3-6)

### 3.1 Device Initialization

**File**: `rdma-transport/src/rdma/device.rs`

```rust
impl RdmaDevice {
    pub fn open(device_name: &str) -> Result<Self> {
        // 1. Get device list: ibv_get_device_list()
        // 2. Find device by name
        // 3. Open context: ibv_open_device()
        // 4. Query device attributes: ibv_query_device()
        // 5. Allocate protection domain: ibv_alloc_pd()
    }
    
    pub fn query_port(&self, port_num: u8) -> Result<PortAttr> {
        // ibv_query_port() - Get port state, GID, LID
    }
    
    pub fn register_memory(&self, addr: *mut u8, len: usize) 
        -> Result<RdmaMemoryRegion> {
        // ibv_reg_mr() with IBV_ACCESS_LOCAL_WRITE | 
        //                    IBV_ACCESS_REMOTE_READ |
        //                    IBV_ACCESS_REMOTE_WRITE
    }
}
```

### 3.2 Connection Setup

**File**: `rdma-transport/src/rdma/connection.rs`

**Connection Flow:**
1. Create Completion Queues (CQ)
2. Create Queue Pair (QP) in RESET state
3. Exchange QP info (QPN, LID, GID) via TCP/coordinator
4. Modify QP: RESET → INIT → RTR → RTS

```rust
pub struct QpEndpoint {
    pub qpn: u32,        // Queue Pair Number
    pub lid: u16,        // Local Identifier
    pub gid: [u8; 16],   // Global Identifier (IPv6-like)
    pub psn: u32,        // Packet Sequence Number
}

impl RdmaConnection {
    pub fn create_qp(device: &RdmaDevice, cq_size: u32) 
        -> Result<Self> {
        // 1. Create CQs: ibv_create_cq()
        // 2. Create QP: ibv_create_qp() with RC type
        // 3. Get local endpoint info
    }
    
    pub fn connect(&mut self, remote_ep: &QpEndpoint) 
        -> Result<()> {
        // 1. QP RESET → INIT: ibv_modify_qp()
        // 2. QP INIT → RTR: set remote endpoint info
        // 3. QP RTR → RTS: set retry params
    }
}
```

### 3.3 RDMA Operations

**File**: `rdma-transport/src/rdma/operations.rs`

```rust
impl RdmaConnection {
    /// RDMA READ: Fetch data from remote memory
    pub fn rdma_read(
        &self,
        local_mr: &RdmaMemoryRegion,
        local_offset: usize,
        remote_addr: u64,
        remote_key: u32,
        length: usize,
    ) -> Result<()> {
        // 1. Prepare work request (WR)
        let mut wr = ibv_send_wr {
            wr_id: generate_wr_id(),
            opcode: IBV_WR_RDMA_READ,
            send_flags: IBV_SEND_SIGNALED,
            sg_list: &[sge],
            wr: ibv_send_wr__bindgen_ty_1 {
                rdma: ibv_send_wr__bindgen_ty_1__bindgen_ty_1 {
                    remote_addr,
                    rkey: remote_key,
                },
            },
            ..Default::default()
        };
        
        // 2. Post send: ibv_post_send()
        unsafe { ibv_post_send(self.qp, &mut wr, &mut bad_wr) }?;
        
        // 3. Poll for completion
        self.poll_completion(wr.wr_id)
    }
    
    /// RDMA WRITE: Send data to remote memory
    pub fn rdma_write(
        &self,
        local_mr: &RdmaMemoryRegion,
        local_offset: usize,
        remote_addr: u64,
        remote_key: u32,
        length: usize,
    ) -> Result<()> {
        // Similar to READ but with IBV_WR_RDMA_WRITE
    }
    
    fn poll_completion(&self, wr_id: u64) -> Result<()> {
        let mut wc = ibv_wc::default();
        loop {
            let n = unsafe { 
                ibv_poll_cq(self.cq_send, 1, &mut wc) 
            };
            
            if n > 0 {
                if wc.status != IBV_WC_SUCCESS {
                    return Err(anyhow!("RDMA op failed: {}", wc.status));
                }
                if wc.wr_id == wr_id {
                    return Ok(());
                }
            }
        }
    }
}
```

### 3.4 Page Transfer API

**File**: `rdma-transport/src/lib.rs` (update existing)

```rust
impl RdmaConnection {
    pub fn fetch_page(
        &self,
        gpa: u64,
        buffer: &mut [u8; PAGE_SIZE],
    ) -> Result<Duration> {
        let start = Instant::now();
        
        // Get remote memory info from coordinator
        let remote_info = self.get_remote_page_info(gpa)?;
        
        // RDMA READ from remote node
        self.rdma_read(
            &self.local_mr,
            0,
            remote_info.addr,
            remote_info.rkey,
            PAGE_SIZE,
        )?;
        
        // Copy to output buffer
        unsafe {
            std::ptr::copy_nonoverlapping(
                self.local_mr.addr,
                buffer.as_mut_ptr(),
                PAGE_SIZE,
            );
        }
        
        Ok(start.elapsed())
    }
}
```

## Phase 4: Integration (Days 7-8)

### 4.1 Update TransportManager

Replace stub implementation with real RDMA:

```rust
impl TransportManager {
    pub fn new(local_node: u32) -> Result<Self> {
        // Open RDMA device
        let device = RdmaDevice::open("mlx5_0")?;
        
        // Register page buffer pool
        let page_pool = alloc_page_pool(1024)?;
        let mr = device.register_memory(
            page_pool.as_ptr(),
            page_pool.len(),
        )?;
        
        Ok(Self {
            local_node,
            device: Arc::new(device),
            mr: Arc::new(mr),
            connections: Arc::new(RwLock::new(HashMap::new())),
        })
    }
}
```

### 4.2 Coordinator Integration

**Endpoint Exchange:**
- Coordinator stores QP endpoints for each node
- New endpoint: `POST /nodes/{id}/endpoint`
- Query endpoint: `GET /nodes/{id}/endpoint`

```python
# coordinator/coordinator.py
@app.post("/nodes/{node_id}/rdma/endpoint")
async def register_rdma_endpoint(
    node_id: int,
    endpoint: RdmaEndpoint
):
    """Register RDMA QP endpoint for a node"""
    nodes[node_id].rdma_endpoint = endpoint
    return {"status": "registered"}

@app.get("/nodes/{node_id}/rdma/endpoint")
async def get_rdma_endpoint(node_id: int):
    """Get RDMA endpoint for remote connection"""
    return nodes[node_id].rdma_endpoint
```

## Phase 5: Testing & Optimization (Days 9-12)

### 5.1 Unit Tests

```rust
#[test]
fn test_rdma_device_open() {
    let device = RdmaDevice::open("mlx5_0");
    assert!(device.is_ok());
}

#[test]
fn test_rdma_memory_registration() {
    let device = RdmaDevice::open("mlx5_0").unwrap();
    let mut buffer = vec![0u8; PAGE_SIZE];
    let mr = device.register_memory(
        buffer.as_mut_ptr(),
        buffer.len(),
    );
    assert!(mr.is_ok());
}

#[test]
fn test_qp_creation_and_transition() {
    let device = RdmaDevice::open("mlx5_0").unwrap();
    let qp = RdmaConnection::create_qp(&device, 128);
    assert!(qp.is_ok());
}
```

### 5.2 Integration Tests

```rust
#[test]
fn test_two_node_page_transfer() {
    // Setup two nodes with RDMA
    let node0 = setup_node(0);
    let node1 = setup_node(1);
    
    // Exchange endpoints
    node0.connect_to(&node1);
    
    // Write page on node1
    let page = vec![0xAB; PAGE_SIZE];
    node1.write_page(0x1000, &page);
    
    // Fetch page from node0
    let fetched = node0.fetch_page(1, 0x1000).unwrap();
    
    assert_eq!(fetched, page);
}
```

### 5.3 Latency Benchmarks

```rust
#[bench]
fn bench_rdma_read_4k(b: &mut Bencher) {
    let conn = setup_rdma_connection();
    let mut buffer = [0u8; PAGE_SIZE];
    
    b.iter(|| {
        conn.fetch_page(0x1000, &mut buffer).unwrap()
    });
}
```

**Target Metrics:**
- Median: <100µs
- P99: <500µs
- Throughput: >10GB/s

### 5.4 Optimization Techniques

**1. Inline RDMA Operations:**
- Use `IBV_SEND_INLINE` for small transfers
- Avoid DMA setup overhead

**2. Completion Queue Batching:**
- Poll multiple completions at once
- Reduce syscall overhead

**3. Memory Registration Caching:**
- Pre-register page pools
- Avoid runtime registration

**4. Queue Pair Tuning:**
- Increase QP depth for pipelining
- Tune retry timeout and RNR timer

**5. CPU Pinning:**
- Pin CQ polling thread to isolated core
- Reduce context switches

## Phase 6: Documentation & Deployment (Days 13-14)

### 6.1 Update Documentation

- README.md - Add RDMA setup instructions
- DEVELOPMENT.md - RDMA troubleshooting
- M2 completion summary

### 6.2 Deployment Guide

```markdown
# RDMA Setup for SSI-HV

## Hardware Requirements
- InfiniBand HCA or RoCEv2 NIC (Mellanox recommended)
- Switched fabric or direct connection
- Linux kernel >= 5.15

## Software Setup
1. Install rdma-core
2. Configure network (IP over IB or RoCE)
3. Verify connectivity: `ibv_rc_pingpong`
4. Deploy SSI-HV

## Performance Tuning
- MTU: 4096 for IB, 1500-9000 for RoCE
- Congestion control: PFC for RoCE
- IRQ affinity: pin to NUMA node
```

## Success Criteria

- ✅ RDMA READ latency: median <100µs, p99 <500µs
- ✅ All unit tests passing
- ✅ Two-node integration test successful
- ✅ Coordinator endpoint exchange working
- ✅ Fallback to TCP when RDMA unavailable
- ✅ Documentation complete
- ✅ Ready for M3 (two-node Linux boot)

## Risk Mitigation

**Risk 1: No RDMA hardware available**
- Mitigation: Use SoftRoCE for development
- Acceptance: Higher latency expected (~200-300µs)

**Risk 2: Binding generation issues**
- Mitigation: Use pre-generated bindings as fallback
- Alternative: Manually write FFI wrapper

**Risk 3: QP state machine complexity**
- Mitigation: Study existing implementations (rust-ibverbs examples)
- Reference: RDMA Aware Networks Programming User Manual

## Timeline

- **Day 1-2**: Setup, bindgen, device opening
- **Day 3-4**: QP creation and state transitions
- **Day 5-6**: RDMA READ/WRITE operations
- **Day 7-8**: Integration with TransportManager
- **Day 9-10**: Testing and benchmarking
- **Day 11-12**: Optimization (<100µs target)
- **Day 13-14**: Documentation and M3 prep

**Total**: 2 weeks (Oct 21 - Nov 3, 2025)

## References

- [RDMA Aware Networks Programming User Manual](https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf)
- [libibverbs man pages](https://linux.die.net/man/3/ibv_post_send)
- [rust-ibverbs examples](https://github.com/jonhoo/rust-ibverbs) (archived but useful)
- [SoftRoCE setup](https://github.com/SoftRoCE/rxe-dev/wiki/rxe-dev:-Home)
- [Rust bindgen guide](https://rust-lang.github.io/rust-bindgen/)
